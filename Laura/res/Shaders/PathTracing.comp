// Thanks to Sebastian Lague: https://www.youtube.com/watch?v=Qz0KTGYJtUk
#version 460 core

#define heatmap_cold vec3(0.0, 0.0, 2.0)
#define heatmap_warm vec3(0.9, 1.0, 0.9)

#define PI 3.1415926
#define EPSILON 1.0e-10 // Small value to avoid division by zero
#define GAMMA 0.8
#define INF 1.0 / 0.0;

#define LOCAL_GROUP_X 8
#define LOCAL_GROUP_Y 4
#define LOCAL_GROUP_Z 1

layout (local_size_x = LOCAL_GROUP_X, local_size_y = LOCAL_GROUP_Y, local_size_z = LOCAL_GROUP_Z) in;

/* The following structs MUST be defined exactly as they are on the CPU. */
// std430 - 32 bytes (CPU side defined in Assets/BVHAccel.h)
struct BVHNode {
	vec3 min;
    uint leftChild_Or_FirstTri;
	vec3 max;
    uint triCount;
	/*	if primCount == 0: leftChild_Or_FirstTri == leftChild
		else leftChild_Or_FirstTri == firstTri */
};

// std430 - 48 bytes (CPU side defined in Assets/AssetTypes.h
struct Triangle {
	vec4 v0, v1, v2;
};

// std430 - 24 bytes (CPU side defined in Renderer/Renderer.h
struct EntityHandle {
	uint rootTriIdx;
	uint triCount;
	uint rootNodeIdx;
	uint nodeCount;

    uint transformIdx;
    uint materialIdx;
};

// std430 - 32 bytes (CPU side defined in Assets/AssetTypes.h)
struct Material {
    vec4 emission; // .xyz=color, .w=strength
    vec4 color;
};


/* Shader specific structs (don't have CPU counterpart) */
struct Ray {
    vec3 origin;
    float t; 
    vec3 dir;
    uint materialIdx;
    vec3 normal;
};

layout (rgba32f, binding = 0) uniform image2D rayTracingTexture;

layout (binding = 1) uniform sampler2D skyboxTexture;

layout (std140, binding = 0) uniform CameraUBO {
    mat4 u_CameraTransform;
    float u_FocalLength;
};

layout (std140, binding = 1) uniform SettingsUBO {
    uint u_RaysPerPixel;
    uint u_BouncesPerRay;
    uint u_heatmap_color_limit;
    uint u_numAccumulatedFrames;
    uint u_EntityCount;
    uint u_displayBVH;
};

layout (std430, binding = 0) buffer EntityLookupSSBO {
    EntityHandle EntityLookupTable[];
};

layout (std430, binding = 1) buffer TransformSSBO {
    mat4 TransformBuffer[];
};

layout (std430, binding = 2) buffer MaterialSSBO {
    Material MaterialBuffer[];
};

layout (std430, binding = 3) buffer MeshBufferSSBO {
    Triangle MeshBuffer[];
};

layout (std430, binding = 4) buffer NodeBufferSSBO {
    BVHNode NodeBuffer[];
};

layout (std430, binding = 5) buffer IndexBufferSSBO {
    uint IndexBuffer[];
};


/** The function getCurrentState calculates a unique state value based on the texel coordinates and the number of accumulated frames.
 * The state value is used to generate random numbers for sampling in the shader.
 */
uint getCurrentState(ivec2 texelCoords, int screenWidth){
    uint pixelIndex = (uint(texelCoords.y) * uint(screenWidth)) + uint(texelCoords.x);
    return pixelIndex + u_numAccumulatedFrames * 745621; // new state every frame
}

/** The RandomValue function generates a random value between 0 and 1 using a simple linear congruential generator (LCG).
 * The function uses the LCG algorithm to generate a sequence of pseudo-random numbers based on a seed value.
 * Thanks to https://www.pcg-random.org, https://www.shadertoy.com/view/XlGcRh
 */
float RandomValue(inout uint state){
    state = state * 747796405u + 2891336453u;
    uint result = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    result = (result >> 22u) ^ result;
    return float(result) / 4294967295.0;
}

/** The RandomValueNormalDistribution function generates a random value from a normal distribution using the Box-Muller transform.
 * The function generates two random values from a uniform distribution and transforms them into a random value from a normal distribution.
 * Thanks to https://stackoverflow.com/a/6178290
 */
float RandomValueNormalDistribution(inout uint state){
    float theta = 2 * PI * RandomValue(state);
    float rho = sqrt(-2 * log(RandomValue(state)));
    return rho * cos(theta);
}

/** The RandomDirection function generates a random direction vector by sampling from a normal distribution in three dimensions.
 * The function generates three random values from a normal distribution and normalizes them to create a random direction vector.
 * Thanks to https://math.stackexchange.com/questions/1585975
 */
vec3 RandomDirection(inout uint state){
    float x = RandomValueNormalDistribution(state);
    float y = RandomValueNormalDistribution(state);
    float z = RandomValueNormalDistribution(state);
    return normalize(vec3(x, y, z));
}

/** The RandomDirectionInHemisphere function generates a random direction vector in the hemisphere defined by the normal vector.
 * The distribution is cosine-weighted. (meaning more rays are sent in the direction of the normal)
 */
vec3 RandomDirectionInHemisphere(vec3 normalVector, inout uint state){
    vec3 randomDirectionVector = RandomDirection(state);
    if (dot(normalVector, randomDirectionVector) < 0){
        randomDirectionVector = -randomDirectionVector;
    }
    return randomDirectionVector;
}

/** The GainSkyboxLight function calculates the color of the skybox based on the direction of the ray.
 * The function uses a gradient from the horizon color to the zenith color to simulate the sky.
 */
vec3 GainSkyboxLight(const Ray ray){
    float u = 0.5f + atan(ray.dir.z, ray.dir.x) / (2.0f * PI);
    float v = 0.5f + asin(ray.dir.y) / PI;
    vec3 texelColor = texture(skyboxTexture, vec2(u, v)).rgb;
    return texelColor;
}

/** The complexityToRGB function converts a complexity value to an RGB color using a rainbow color map.
 * The function maps the complexity value to a wavelength in the visible spectrum and then converts the wavelength to an RGB color.
 * The RGB color is gamma-corrected to ensure that the colors are displayed correctly on the screen.
 */
vec3 complexityToRGB(uint complexity) 
{
	float wavelength = 380.0 + 370.0 * complexity/(u_heatmap_color_limit);
    vec3 color;
    if (wavelength <= 380.0) {
		color.r = 0.0;
		color.g = 0.0;
		color.b = 0.0;
	}
    else if (wavelength > 380.0 && wavelength <= 440.0) {
        color.r = -(wavelength - 440.0) / (440.0 - 380.0)/3;
        color.g = 0.0;
        color.b = 0.8;
    } else if (wavelength >= 440.0 && wavelength <= 490.0) {
        color.r = 0.0;
        color.g = (wavelength - 440.0) / (490.0 - 440.0);
        color.b = 1.0;
    } else if (wavelength >= 490.0 && wavelength <= 510.0) {
        color.r = 0.0;
        color.g = 1.0;
        color.b = -(wavelength - 510.0) / (510.0 - 490.0);
    } else if (wavelength >= 510.0 && wavelength <= 580.0) {
        color.r = (wavelength - 510.0) / (580.0 - 510.0);
        color.g = 1.0;
        color.b = 0.0;
    } else if (wavelength >= 580.0 && wavelength <= 645.0) {
        color.r = 1.0;
        color.g = -(wavelength - 645.0) / (645.0 - 580.0);
        color.b = 0.0;
    } else if (wavelength >= 645.0 && wavelength <= 780.0) {
        color.r = 1.0;
        color.g = 0.0;
        color.b = 0.0;
    } else {
        color.r = 1.0;
        color.g = 1.0;
        color.b = 1.0;
    }

    float factor;
    vec3 white = vec3(1.0);
    
    if (wavelength >= 380 && wavelength < 420){
        factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380);
    }
    else if (wavelength >= 420 && wavelength < 701){
		factor = 1.0;
	}
	else if (wavelength >= 701 && wavelength < 781){
        factor = 0.3 + 0.7*(780 - wavelength) / (780 - 700);
        return pow((color + factor*white), vec3(GAMMA));
    }
    else {
        factor = 1.0;
    }

    return pow(factor * color, vec3(GAMMA)); //gamma correction component-wise
}

// Slab method Ray-AABB intersection algorithm
// Thanks to: https://tavianator.com/fast-branchless-raybounding-box-intersections/ and https://tavianator.com/2022/ray_box_boundary.html
float IntersectAABB(const Ray ray, const vec3 bmin, const vec3 bmax) {
    vec3 t1 = (bmin - ray.origin) / ray.dir;
    vec3 t2 = (bmax - ray.origin) / ray.dir;
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    float tNear = max(max(tMin.x, tMin.y), tMin.z);
    float tFar  = min(min(tMax.x, tMax.y), tMax.z);
    return (tFar >= tNear && tNear < ray.t && tFar > 0.0) ? tNear : 1e30f;
}

// Moller Trumbore Ray-Triangle intersection algorithm
bool IntersectTri(inout Ray r, const Triangle tri) {
    const vec3 E1 = tri.v1.xyz - tri.v0.xyz;
    const vec3 E2 = tri.v2.xyz - tri.v0.xyz;
    vec3 Ng = cross(E1, E2);
    float det = -dot(r.dir, Ng);
    if (det < 1e-6) return false;

    float invdet = 1.0 / det;
    vec3 AO  = r.origin - tri.v0.xyz;
    vec3 DAO = cross(AO, r.dir);
    float t = dot(AO, Ng) * invdet;
    float u = dot(E2, DAO) * invdet;
    float v = -dot(E1, DAO) * invdet;
    if (t < 0.0 || u < 0.0 || v < 0.0 || (u + v) > 1.0) return false;
    if (t >= r.t) return false;

    r.t = t;
    r.normal = normalize(Ng);
    return true;
}

void TraverseBVH(inout Ray ray, inout EntityHandle entityHandle, inout uint AABB_intersect_count, inout uint TRI_intersect_count) {
    uint nodeOffset = entityHandle.rootNodeIdx; // caused by consecutive BVHs in one buffer
    uint nodeIdx = 0;
    uint stack[64]; // Array of indices pointing to BVHNodes
    uint stackPtr = 0;

    while (true) {
        if (NodeBuffer[nodeOffset + nodeIdx].triCount != 0) { // is leaf
        for (uint i = 0; i < NodeBuffer[nodeOffset + nodeIdx].triCount; i++) {
            const Triangle tri = MeshBuffer[
                entityHandle.rootTriIdx +
                IndexBuffer[entityHandle.rootTriIdx + NodeBuffer[nodeOffset + nodeIdx].leftChild_Or_FirstTri + i]
            ];
            if (IntersectTri(ray, tri)) {
                TRI_intersect_count += 1;
                ray.materialIdx = entityHandle.materialIdx;
            }
        }

            if (stackPtr == 0) { break; }
            else { nodeIdx = stack[--stackPtr]; }
            continue;
        }

        uint child1Idx = NodeBuffer[nodeOffset + nodeIdx].leftChild_Or_FirstTri;
        uint child2Idx = NodeBuffer[nodeOffset + nodeIdx].leftChild_Or_FirstTri + 1;

        float dist1 = IntersectAABB(ray,
            NodeBuffer[nodeOffset + child1Idx].min,
            NodeBuffer[nodeOffset + child1Idx].max);
        float dist2 = IntersectAABB(ray,
            NodeBuffer[nodeOffset + child2Idx].min,
            NodeBuffer[nodeOffset + child2Idx].max);

        if (dist1 < 1e30f) { AABB_intersect_count++; }
        if (dist2 < 1e30f) { AABB_intersect_count++; }

        if (dist1 > dist2) {
            float tmpDist = dist1; dist1 = dist2; dist2 = tmpDist;              // swap(dist1, dist2)
            uint tmpIdx = child1Idx; child1Idx = child2Idx; child2Idx = tmpIdx;  // swap(child1Idx, child2Idx)
        }

        if (dist1 >= 1e30f) {
            if (stackPtr == 0) { break; }
            else { nodeIdx = stack[--stackPtr]; }
        } else {
            nodeIdx = child1Idx;
            if (dist2 < 1e30f) { stack[stackPtr++] = child2Idx; }
        }
    }
}

void CheckRayCollision(inout Ray ray, inout uint AABB_intersect_count, inout uint TRI_intersect_count) {
    ray.t = 1e30f;
    mat4 closestHitTransform = mat4(1.0);
    for (int i = 0; i < u_EntityCount; i++) {
        // Transform ray to the local space of the tested entity 
        EntityHandle entityHandle = EntityLookupTable[i];
        mat4 model = TransformBuffer[entityHandle.transformIdx];
        mat4 invTransform = inverse(model);

        Ray rayLocal;
        rayLocal.t = 1e30f; 
        rayLocal.origin = (invTransform * vec4(ray.origin, 1.0)).xyz;
        rayLocal.dir = (invTransform * vec4(ray.dir, 0.0)).xyz;
		
        TraverseBVH(rayLocal, entityHandle, AABB_intersect_count, TRI_intersect_count);

        if (rayLocal.t < ray.t){
            // compute world-space hit point and normal, and world-space distance
            vec3 localHit = rayLocal.origin + rayLocal.dir * rayLocal.t;
            vec3 worldHit = (model * vec4(localHit, 1.0)).xyz;
            mat3 normalMatrix = mat3(transpose(inverse(model)));
            vec3 worldNormal = normalize(normalMatrix * rayLocal.normal);
            float worldT = length(worldHit - ray.origin);

            ray.t = worldT;
            ray.normal = faceforward(worldNormal, ray.dir, worldNormal);
            ray.materialIdx = rayLocal.materialIdx;
            closestHitTransform = model;
        }
    }
}

vec3 TraceRay(inout Ray ray, inout uint state, inout uint AABB_intersect_count, inout uint TRI_intersect_count) {
    vec3 rayColor = vec3(1.0);
    vec3 brightness_score = vec3(0.0);
    
    for (int i = 0; i < int(u_BouncesPerRay); i++) {
        CheckRayCollision(ray, AABB_intersect_count, TRI_intersect_count);

        if (ray.t < 1e30f) { // did collide
            // advance origin to hit point with small bias along normal to avoid self-intersection
            ray.origin = ray.origin + ray.dir * ray.t + ray.normal * 1e-4;
            // cosine-weighted hemisphere sampling around the surface normal
            ray.dir = normalize(ray.normal + RandomDirection(state));
            vec3 emittedLight = MaterialBuffer[ray.materialIdx].emission.xyz * 
                                MaterialBuffer[ray.materialIdx].emission.w;

            rayColor *= MaterialBuffer[ray.materialIdx].color.xyz;
            brightness_score += emittedLight * rayColor;
        }
        else {
            brightness_score += GainSkyboxLight(ray) * rayColor;
            break;
        }
    }
    return brightness_score;
}


void main() {
    // Find texel (texture pixel coordinates)
    ivec2 texelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(rayTracingTexture);
    if (texelCoords.x >= dims.x || texelCoords.y >= dims.y) { return; }
    float x = (float(texelCoords.x * 2 - dims.x) / dims.x); // map to <-1.0; 1.0>
    float y = (float(texelCoords.y * 2 - dims.y) / dims.x); // divide by x to keep ratio
    
    Ray ray;
    // Transform Ray origin from local to WORLD space using Camera's Transform
    vec4 rayOriginHomogeneous = vec4(0.0f, 0.0f, 0.0f, 1.0f);
    rayOriginHomogeneous = u_CameraTransform * rayOriginHomogeneous;
    vec3 rayOrigin = rayOriginHomogeneous.xyz / rayOriginHomogeneous.w;

    // Same with Ray direction (no translation needed <=> no homogeneous coordinates)
    vec3 rayDirectionLocal = vec3(x, y, u_FocalLength); // focalLengh = distance between origin & screen plane
    vec3 rayDir = normalize(mat3(u_CameraTransform) * rayDirectionLocal);

    uint AABB_intersect_count = 0; 
    uint TRI_intersect_count = 0;
    vec3 pixelColor = vec3(0.0);
    uint state = getCurrentState(texelCoords, dims.x);
    for (int i = 0; i < u_RaysPerPixel; i++) {
        ray.origin = rayOrigin;
        ray.dir = rayDir;
        pixelColor += TraceRay(ray, state, AABB_intersect_count, TRI_intersect_count);
    }

    if (u_displayBVH == 1)
        pixelColor = complexityToRGB(AABB_intersect_count + 3*TRI_intersect_count);
    else
        pixelColor = pixelColor / u_RaysPerPixel;
    
    // combine accumulated & current pixelColor
    float weight = 1.0f / (u_numAccumulatedFrames + 1);
    vec3 outputColor = imageLoad(rayTracingTexture, texelCoords).rgb * (1 - weight) + pixelColor * weight;
    imageStore(rayTracingTexture, texelCoords, vec4(outputColor, 1.0f));
    //barrier(); // wait for all threads to finish
};